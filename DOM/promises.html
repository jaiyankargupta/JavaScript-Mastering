A Promise, like a movie in production, can exist in one of three states:

Pending: The opening scene; the promise is awaiting either fulfillment or rejection.
Fulfilled: The climax; the operation completed successfully, and the promise holds a resulting value.
Rejected: The plot twist; an error occurred during the operation, and the promise contains a reason for the failure.



In the grand production of JavaScript, a Promise is an object representing the eventual completion or failure of an asynchronous operation. Promises are the actors that bring order to the chaos, making it easier to write asynchronous code in a well-organized and readable manner.


const myPromise = new Promise((resolve, reject) => {
    // Simulating an asynchronous operation (e.g., fetching data from an API)
    setTimeout(() => {
        const success = true; // Simulating a successful operation, set to false for failure

        if (success) {
            // If the operation is successful, resolve the Promise
            resolve('Data successfully fetched');
        } else {
            // If there's an error, reject the Promise
            reject('Error fetching data');
        }
    }, 2000); // Simulating a delay of 2 seconds
});


In this scene, inside the Promise constructor, there's a simulated asynchronous operation using setTimeout. If the operation is successful, the Promise is resolved with a message; otherwise, it is rejected with an error message. The suspense builds as the audience wonders about the fate of the asynchronous operation.


Handling Promises: A Director's Cut with then(), catch(), and finally()



then() method:
It is used to handle the fulfillment (success) of a Promise. It takes one or two optional callback functions as arguments. The first callback is called when the Promise is resolved. The second callback (optional) is called when the Promise is rejected.

// Using then for handling fulfillment
promiseObject.then(
  (result) => {
    // Handle success
    console.log(result);
  },
  (error) => {
    // Handle rejection (optional)
    console.error(error);
  }
);


In this riveting scene, the then method orchestrates the success and failure of the Promise, much like a director guiding actors through crucial moments in the storyline.


//chaining the then method

promiseObject
  .then((result1) => {
    // Handle result1
    return result1 + 1;
  })
  .then((result2) => {
    // Handle result2 (which is result1 + 1)
    console.log(result2);
  })


  The plot thickens as then methods are chained together, forming a sequel of asynchronous operations. Each then builds upon the result of the previous one, creating a storyline filled with twists and turns.
  
  
catch() method: Navigating Through Plot Twists
It is used to handle the rejection (failure) of a Promise. It takes a callback function that is called when the Promise is rejected. It is an alternative to providing the rejection callback in the then method.


promiseObject.catch((error) => {
    // Handle rejection
    console.error(error);
  });


  As the plot takes an unexpected turn, the catch method swoops in to handle the rejection, much like a skilled director navigating through plot twists.
  
  
  finally() method: The Grand Finale
  The finally method is used to specify a callback function to be executed regardless of whether the Promise is fulfilled or rejected. It's often used for cleanup operations. 

  promiseObject
  .then((result) => {
    // Handle success
    console.log(result);
  })
  .catch((error) => {
    // Handle rejection
    console.error(error);
  })
  .finally(() => {
    // This block will be executed regardless of the Promise's state
    console.log('Finally block executed');
  });


  As the grand finale approaches, the finally method takes center stage, ensuring that the designated block of code is executed regardless of how the Promise concludes. It's the concluding scene, leaving a lasting impression on the audience.
  
  
Resolve() and Reject(): Static Methods as Plot Enablers
Certainly! In the world of JavaScript Promises, the resolve() and reject() methods are the unseen scriptwriters, crafting the plot by creating and handling resolved or rejected Promise instances.

const resolvedPromise = Promise.resolve('Resolved value');

resolvedPromise.then((result) => {
  console.log(result); // Output: Resolved value
});

In this empowering scene, Promise.resolve() takes the lead, creating a Promise that is immediately resolved with the value 'Resolved value'. The audience witnesses the power of resolution in action.



const anotherPromise = new Promise((resolve, reject) => {
    // Some asynchronous operation
    resolve('Async operation resolved');
  });
  
  const resolvedWithPromise = Promise.resolve(anotherPromise);
  
  resolvedWithPromise.then((result) => {
    console.log(result); // Output: Async operation resolved
  });



const rejectedPromise = Promise.reject('Error reason');

rejectedPromise.catch((error) => {
  console.error(error); // Output: Error reason
});

In a dramatic turn of events, Promise.reject() sets the stage for conflict, creating a Promise that is immediately rejected with the reason 'Error reason'. The audience braces for impact as rejection takes center stage.


const anotherPromise = new Promise((resolve, reject) => {
    // Some asynchronous operation that fails
    reject('Async operation failed');
  });
  
  const rejectedWithPromise = Promise.reject(anotherPromise);
  
  rejectedWithPromise.catch((error) => {
    console.error(error); // Output: Async operation failed
  });


  myPromise
  .then((result1) => {
    // Handle result1
    return result1 + 1; // Can return a value or a new promise
  })
  .then((result2) => {
    // Handle the result of the second asynchronous operation
    console.log(result2);
  });  

  The symphony begins as then methods are chained together, creating a harmonious composition. Each then block receives the result of the previous one, contributing to the seamless flow of the narrative.
  
  
  asyncOperation1()
  .then((result1) => {
    // Handle result1
    return asyncOperation2(result1);
  })
  .then((result2) => {
    // Handle result2 (which is the result of asyncOperation2)
    return asyncOperation3(result2);
  })
  .then((result3) => {
    // Handle result3 (which is the result of asyncOperation3)
    console.log(result3);
  })
  .catch((error) => {
    // Handle errors in any stage of the sequence
    console.error(error);
  });



  The plot thickens as promises are chained for sequential operations. Each then block builds upon the previous one, and the audience is taken on a journey through the interconnected scenes of asynchronous operations.

Chaining promises transforms the code into a compelling script, making it more readable and avoiding the chaos of callback hell. It ensures a clear and captivating flow of execution, much like a well-orchestrated movie screenplay.




const promises = [promise1, promise2, promise3];

Promise.all(promises)
  .then((results) => {
    console.log("All promises fulfilled:", results);
  })
  .catch((error) => {
    console.error("At least one promise rejected:", error);
  });


  In this powerful scene, Promise.all() takes the stage, orchestrating harmony in completion. All promises must fulfill their roles for the show to go on. If any promise falters, an unforeseen event takes place, echoing through the narrative. 

  Promise.allSettled([promise1, promise2, promise3])
  .then((results) => {
    console.log("All promises settled:", results);
  });

  Promise.allSettled() emerges as the silent observer, waiting for every outcome to unfold. Regardless of success or failure, it captures the essence of each promise's journey, providing a comprehensive look behind the scenes.


  Promise.any([promise1, promise2, promise3])
  .then((result) => {
    console.log("At least one promise fulfilled:", result);
  });

  In a race against time, Promise.any() mirrors the thrilling pursuit of the first fulfilled promise. The narrative intensifies as promises compete for the spotlight, and the first one to succeed takes center stage.


  Promise.race([promise1, promise2, promise3])
  .then((result) => {
    console.log("The first promise to settle:", result);
  });

  Promise.race() unfolds as the swift revelation, showcasing the result of the first promise to settle. The narrative takes an unexpected turn, aligning with the first promise to either triumph or face a rapid downfall.



  // Async Function Definition
  async function playSuspensefulMusic(minutes) {
    console.log("Enchanting suspenseful music echoes...");
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log("Suspense Revealed");
        resolve("Vinayak Mahadev and Prithvi walk away with bags of money");
      }, minutes * 60 * 1000);
    });
  }
  
  // Async Function Call
  async function climaxScene() {
    console.log('Vinayak whispers "Action King" over the phone');
    const result = await playSuspensefulMusic(3);
    console.log("Climax Revealed:", result);
  }
  
  // Initiating the Climax Scene
  climaxScene();






  Fetch Data 

  fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    // Work with JSON data
    console.log(data);
  })
  .catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });




  fetch('https://api.example.com/data', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      key: 'value'
    })
  })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
  



  async function fetchData() {
    try {
      const response = await fetch('https://api.example.com/data');
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      const data = await response.json();
      console.log(data);
    } catch (error) {
      console.error('There was a problem with the fetch operation:', error);
    }
  }
  
  fetchData();
  